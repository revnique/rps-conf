"use strict";
const plugins_source_base_1 = require("./plugins-source-base");
const Future = require("fibers/future");
class NpmRegistryPluginsSource extends plugins_source_base_1.PluginsSourceBase {
    constructor($progressIndicator, $logger, $httpClient, $childProcess, $hostInfo, $npmService, $errors) {
        super($progressIndicator, $logger);
        this.$httpClient = $httpClient;
        this.$childProcess = $childProcess;
        this.$hostInfo = $hostInfo;
        this.$npmService = $npmService;
        this.$errors = $errors;
    }
    get progressIndicatorMessage() {
        return "Searching for plugin in http://registry.npmjs.org.";
    }
    getPlugins(page, count) {
        return Future.fromResult(page === 1 ? this.plugins : null);
    }
    initializeCore(projectDir, keywords) {
        return (() => {
            let plugin = this.getPluginFromNpmRegistry(keywords[0]).wait();
            this.plugins = plugin ? [plugin] : null;
        }).future()();
    }
    prepareScopedPluginName(plugin) {
        return plugin.replace("/", "%2F");
    }
    getPluginFromNpmRegistry(plugin) {
        return (() => {
            let dependencyInfo = this.$npmService.getDependencyInformation(plugin);
            let pluginName = this.$npmService.isScopedDependency(plugin) ? this.prepareScopedPluginName(dependencyInfo.name) : dependencyInfo.name;
            let result = this.$npmService.getPackageJsonFromNpmRegistry(pluginName, dependencyInfo.version).wait();
            if (!result) {
                return null;
            }
            result.author = (result.author && result.author.name) || result.author;
            return result;
        }).future()();
    }
}
exports.NpmRegistryPluginsSource = NpmRegistryPluginsSource;
