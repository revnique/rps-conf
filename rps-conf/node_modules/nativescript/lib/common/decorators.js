"use strict";
const fiberBootstrap = require("./fiber-bootstrap");
const assert = require("assert");
const helpers_1 = require("./helpers");
function exportedPromise(moduleName, postAction) {
    return (target, propertyKey, descriptor) => {
        $injector.publicApi.__modules__[moduleName] = $injector.publicApi.__modules__[moduleName] || {};
        $injector.publicApi.__modules__[moduleName][propertyKey] = (...args) => {
            let originalModule = $injector.resolve(moduleName);
            let originalMethod = originalModule[propertyKey];
            let result;
            try {
                result = originalMethod.apply(originalModule, args);
            }
            catch (err) {
                let promise = new Promise((onFulfilled, onRejected) => {
                    onRejected(err);
                });
                return promise;
            }
            let types = _(result)
                .groupBy((f) => typeof f)
                .keys()
                .value(), postActionMethod = postAction && postAction.bind(originalModule);
            if (_.isArray(result) && types.length === 1 && helpers_1.isFuture(_.first(result))) {
                return _.map(result, (future, index) => getPromise(future, {
                    postActionMethod,
                    shouldExecutePostAction: (index + 1) === result.length
                }));
            }
            else {
                return getPromise(result, {
                    postActionMethod,
                    shouldExecutePostAction: !!postAction
                });
            }
        };
        return descriptor;
    };
}
exports.exportedPromise = exportedPromise;
function getPromise(originalValue, config) {
    let postAction = (data) => {
        if (config && config.postActionMethod && config.shouldExecutePostAction) {
            config.postActionMethod();
        }
        if (data instanceof Error) {
            throw data;
        }
        return data;
    };
    return new Promise((onFulfilled, onRejected) => {
        if (helpers_1.isFuture(originalValue)) {
            fiberBootstrap.run(function () {
                try {
                    let realResult = originalValue.wait();
                    onFulfilled(realResult);
                }
                catch (err) {
                    onRejected(err);
                }
            });
        }
        else {
            onFulfilled(originalValue);
        }
    }).then(postAction, postAction);
}
function exported(moduleName) {
    return (target, propertyKey, descriptor) => {
        $injector.publicApi.__modules__[moduleName] = $injector.publicApi.__modules__[moduleName] || {};
        $injector.publicApi.__modules__[moduleName][propertyKey] = (...args) => {
            let originalModule = $injector.resolve(moduleName), originalMethod = originalModule[propertyKey], result = originalMethod.apply(originalModule, args);
            assert.strictEqual(helpers_1.isFuture(result), false, "Cannot use exported decorator with function returning IFuture<T>.");
            return result;
        };
        return descriptor;
    };
}
exports.exported = exported;
