"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const application_manager_base_1 = require("../../application-manager-base");
const Future = require("fibers/future");
const path = require("path");
const temp = require("temp");
const helpers_1 = require("../../../helpers");
class IOSSimulatorApplicationManager extends application_manager_base_1.ApplicationManagerBase {
    constructor(iosSim, identifier, $options, $fs, $bplistParser, $iOSSimulatorLogProvider, $deviceLogProvider, $logger, $hooksService) {
        super($logger, $hooksService);
        this.iosSim = iosSim;
        this.identifier = identifier;
        this.$options = $options;
        this.$fs = $fs;
        this.$bplistParser = $bplistParser;
        this.$iOSSimulatorLogProvider = $iOSSimulatorLogProvider;
        this.$deviceLogProvider = $deviceLogProvider;
    }
    getInstalledApplications() {
        return Future.fromResult(this.iosSim.getInstalledApplications(this.identifier));
    }
    installApplication(packageFilePath) {
        return (() => {
            if (this.$fs.exists(packageFilePath) && path.extname(packageFilePath) === ".zip") {
                temp.track();
                let dir = temp.mkdirSync("simulatorPackage");
                this.$fs.unzip(packageFilePath, dir).wait();
                let app = _.find(this.$fs.readDirectory(dir), directory => path.extname(directory) === ".app");
                if (app) {
                    packageFilePath = path.join(dir, app);
                }
            }
            this.iosSim.installApplication(this.identifier, packageFilePath).wait();
        }).future()();
    }
    uninstallApplication(appIdentifier) {
        return this.iosSim.uninstallApplication(this.identifier, appIdentifier);
    }
    startApplication(appIdentifier) {
        return (() => {
            let launchResult = this.iosSim.startApplication(this.identifier, appIdentifier).wait();
            if (!this.$options.justlaunch) {
                let pid = launchResult.split(":")[1].trim();
                this.$deviceLogProvider.setApplictionPidForDevice(this.identifier, pid);
                this.$iOSSimulatorLogProvider.startLogProcess(this.identifier);
            }
        }).future()();
    }
    stopApplication(cfBundleExecutable) {
        return this.iosSim.stopApplication(this.identifier, cfBundleExecutable);
    }
    canStartApplication() {
        return true;
    }
    getApplicationInfo(applicationIdentifier) {
        return (() => {
            let result = null, plistContent = this.getParsedPlistContent(applicationIdentifier).wait();
            if (plistContent) {
                result = {
                    applicationIdentifier,
                    deviceIdentifier: this.identifier,
                    configuration: plistContent && plistContent.configuration
                };
            }
            return result;
        }).future()();
    }
    isLiveSyncSupported(appIdentifier) {
        return (() => {
            let plistContent = this.getParsedPlistContent(appIdentifier).wait();
            if (plistContent) {
                return !!plistContent && !!plistContent.IceniumLiveSyncEnabled;
            }
            return false;
        }).future()();
    }
    getParsedPlistContent(appIdentifier) {
        return (() => {
            if (!this.isApplicationInstalled(appIdentifier).wait()) {
                return null;
            }
            let applicationPath = this.iosSim.getApplicationPath(this.identifier, appIdentifier), pathToInfoPlist = path.join(applicationPath, "Info.plist");
            return this.$fs.exists(pathToInfoPlist) ? this.$bplistParser.parseFile(pathToInfoPlist).wait()[0] : null;
        }).future()();
    }
    getDebuggableApps() {
        return Future.fromResult([]);
    }
    getDebuggableAppViews(appIdentifiers) {
        return Future.fromResult(null);
    }
}
__decorate([
    helpers_1.hook('install')
], IOSSimulatorApplicationManager.prototype, "installApplication", null);
exports.IOSSimulatorApplicationManager = IOSSimulatorApplicationManager;
