"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const os_1 = require("os");
const application_manager_base_1 = require("../application-manager-base");
const constants_1 = require("../../constants");
const Future = require("fibers/future");
const helpers_1 = require("../../helpers");
class AndroidApplicationManager extends application_manager_base_1.ApplicationManagerBase {
    constructor(adb, identifier, $staticConfig, $options, $logcatHelper, $androidProcessService, $httpClient, $logger, $hooksService) {
        super($logger, $hooksService);
        this.adb = adb;
        this.identifier = identifier;
        this.$staticConfig = $staticConfig;
        this.$options = $options;
        this.$logcatHelper = $logcatHelper;
        this.$androidProcessService = $androidProcessService;
        this.$httpClient = $httpClient;
    }
    getInstalledApplications() {
        return (() => {
            let result = this.adb.executeShellCommand(["pm", "list", "packages"]).wait() || "";
            let regex = /package:(.+)/;
            return result.split(os_1.EOL)
                .map((packageString) => {
                let match = packageString.match(regex);
                return match ? match[1] : null;
            })
                .filter((parsedPackage) => parsedPackage !== null);
        }).future()();
    }
    installApplication(packageFilePath) {
        return this.adb.executeCommand(["install", "-r", `${packageFilePath}`]);
    }
    uninstallApplication(appIdentifier) {
        return this.adb.executeShellCommand(["pm", "uninstall", `${appIdentifier}`], { treatErrorsAsWarnings: true });
    }
    startApplication(appIdentifier, framework) {
        return (() => {
            this.adb.executeShellCommand(["monkey",
                "-p", appIdentifier,
                "-c", "android.intent.category.LAUNCHER",
                "1"]).wait();
            if (!this.$options.justlaunch) {
                this.$logcatHelper.start(this.identifier);
            }
        }).future()();
    }
    stopApplication(appIdentifier) {
        return this.adb.executeShellCommand(["am", "force-stop", `${appIdentifier}`]);
    }
    getApplicationInfo(applicationIdentifier) {
        return Future.fromResult(null);
    }
    canStartApplication() {
        return true;
    }
    isLiveSyncSupported(appIdentifier) {
        return (() => {
            let liveSyncVersion = this.adb.sendBroadcastToDevice(constants_1.LiveSyncConstants.CHECK_LIVESYNC_INTENT_NAME, { "app-id": appIdentifier }).wait();
            return liveSyncVersion === constants_1.LiveSyncConstants.VERSION_2 || liveSyncVersion === constants_1.LiveSyncConstants.VERSION_3;
        }).future()();
    }
    getDebuggableApps() {
        return this.$androidProcessService.getDebuggableApps(this.identifier);
    }
    getDebuggableAppViews(appIdentifiers) {
        return (() => {
            let mappedAppIdentifierPorts = this.$androidProcessService.getMappedAbstractToTcpPorts(this.identifier, appIdentifiers, constants_1.TARGET_FRAMEWORK_IDENTIFIERS.Cordova).wait(), applicationViews = {};
            _.each(mappedAppIdentifierPorts, (port, appIdentifier) => {
                applicationViews[appIdentifier] = [];
                let localAddress = `http://127.0.0.1:${port}/json`;
                try {
                    if (port) {
                        let apps = this.$httpClient.httpRequest(localAddress).wait().body;
                        applicationViews[appIdentifier] = JSON.parse(apps);
                    }
                }
                catch (err) {
                    this.$logger.trace(`Error while checking ${localAddress}. Error is: ${err.message}`);
                }
            });
            return applicationViews;
        }).future()();
    }
}
__decorate([
    helpers_1.hook('install')
], AndroidApplicationManager.prototype, "installApplication", null);
exports.AndroidApplicationManager = AndroidApplicationManager;
