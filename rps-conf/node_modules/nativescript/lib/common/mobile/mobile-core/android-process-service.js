"use strict";
const os_1 = require("os");
const shelljs = require("shelljs");
const device_android_debug_bridge_1 = require("../android/device-android-debug-bridge");
const constants_1 = require("../../constants");
class AndroidProcessService {
    constructor($errors, $staticConfig, $injector, $net, $processService) {
        this.$errors = $errors;
        this.$staticConfig = $staticConfig;
        this.$injector = $injector;
        this.$net = $net;
        this.$processService = $processService;
        this._devicesAdbs = {};
        this._forwardedLocalPorts = [];
    }
    get androidPortInformationRegExp() {
        let wordCharacters = "[0-9A-Za-z]+";
        let hexIpAddressWithPort = "[0-9A-Za-z]+:[0-9A-Za-z]+";
        let hexIpAddressWithPortWithSpace = `${hexIpAddressWithPort}\\s+`;
        let hexIpAddressWithPortWithSpaceMatch = `(${hexIpAddressWithPort})\\s+`;
        return new RegExp(`(\\d+):\\s+${hexIpAddressWithPortWithSpaceMatch}${hexIpAddressWithPortWithSpaceMatch}${wordCharacters}\\s+${hexIpAddressWithPortWithSpace}${hexIpAddressWithPortWithSpace}${wordCharacters}\\s+(\\d+)`, "g");
    }
    mapAbstractToTcpPort(deviceIdentifier, appIdentifier, framework) {
        return (() => {
            this.tryAttachToProcessExitSignals();
            let adb = this.getAdb(deviceIdentifier);
            let processId = this.getProcessIds(adb, [appIdentifier]).wait()[appIdentifier];
            let applicationNotStartedErrorMessage = `The application is not started on the device with identifier ${deviceIdentifier}.`;
            if (!processId) {
                this.$errors.failWithoutHelp(applicationNotStartedErrorMessage);
            }
            let abstractPortsInformation = this.getAbstractPortsInformation(adb).wait();
            let abstractPort = this.getAbstractPortForApplication(adb, processId, appIdentifier, abstractPortsInformation, framework).wait();
            if (!abstractPort) {
                this.$errors.failWithoutHelp(applicationNotStartedErrorMessage);
            }
            let localPort = this.getAlreadyMappedPort(adb, deviceIdentifier, abstractPort).wait();
            if (!localPort) {
                localPort = this.$net.getFreePort().wait();
                adb.executeCommand(["forward", `tcp:${localPort}`, `localabstract:${abstractPort}`]).wait();
            }
            this._forwardedLocalPorts.push(localPort);
            return localPort;
        }).future()();
    }
    getMappedAbstractToTcpPorts(deviceIdentifier, appIdentifiers, framework) {
        return (() => {
            let adb = this.getAdb(deviceIdentifier), abstractPortsInformation = this.getAbstractPortsInformation(adb).wait(), processIds = this.getProcessIds(adb, appIdentifiers).wait(), adbForwardList = adb.executeCommand(["forward", "--list"]).wait(), localPorts = {};
            _.each(appIdentifiers, appIdentifier => {
                localPorts[appIdentifier] = null;
                let processId = processIds[appIdentifier];
                if (!processId) {
                    return;
                }
                let abstractPort = this.getAbstractPortForApplication(adb, processId, appIdentifier, abstractPortsInformation, framework).wait();
                if (!abstractPort) {
                    return;
                }
                let localPort = this.getAlreadyMappedPort(adb, deviceIdentifier, abstractPort, adbForwardList).wait();
                if (localPort) {
                    localPorts[appIdentifier] = localPort;
                }
            });
            return localPorts;
        }).future()();
    }
    getDebuggableApps(deviceIdentifier) {
        return (() => {
            let adb = this.getAdb(deviceIdentifier);
            let androidWebViewPortInformation = this.getAbstractPortsInformation(adb).wait().split(os_1.EOL);
            return _(androidWebViewPortInformation)
                .map(line => this.getApplicationInfoFromWebViewPortInformation(adb, deviceIdentifier, line).wait()
                || this.getNativeScriptApplicationInformation(adb, deviceIdentifier, line).wait())
                .filter(deviceAppInfo => !!deviceAppInfo)
                .groupBy(element => element.framework)
                .map((group) => _.uniqBy(group, g => g.appIdentifier))
                .flatten()
                .value();
        }).future()();
    }
    getApplicationInfoFromWebViewPortInformation(adb, deviceIdentifier, information) {
        return (() => {
            let processIdRegExp = /@webview_devtools_remote_(.+)/g, processIdMatches = processIdRegExp.exec(information), cordovaAppIdentifier;
            if (processIdMatches) {
                let processId = processIdMatches[1];
                cordovaAppIdentifier = this.getApplicationIdentifierFromPid(adb, processId).wait();
            }
            else {
                let chromeAppIdentifierRegExp = /@(.+)_devtools_remote\s?/g;
                let chromeAppIdentifierMatches = chromeAppIdentifierRegExp.exec(information);
                if (chromeAppIdentifierMatches && chromeAppIdentifierMatches.length > 0) {
                    cordovaAppIdentifier = chromeAppIdentifierMatches[1];
                }
            }
            if (cordovaAppIdentifier) {
                return {
                    deviceIdentifier: deviceIdentifier,
                    appIdentifier: cordovaAppIdentifier,
                    framework: constants_1.TARGET_FRAMEWORK_IDENTIFIERS.Cordova
                };
            }
            return null;
        }).future()();
    }
    getNativeScriptApplicationInformation(adb, deviceIdentifier, information) {
        return (() => {
            let nativeScriptAppIdentifierRegExp = /@(.+)-debug/g;
            let nativeScriptAppIdentifierMatches = nativeScriptAppIdentifierRegExp.exec(information);
            if (nativeScriptAppIdentifierMatches && nativeScriptAppIdentifierMatches.length > 0) {
                let appIdentifier = nativeScriptAppIdentifierMatches[1];
                return {
                    deviceIdentifier: deviceIdentifier,
                    appIdentifier: appIdentifier,
                    framework: constants_1.TARGET_FRAMEWORK_IDENTIFIERS.NativeScript
                };
            }
            return null;
        }).future()();
    }
    getAbstractPortForApplication(adb, processId, appIdentifier, abstractPortsInformation, framework) {
        return (() => {
            framework = framework || "";
            switch (framework.toLowerCase()) {
                case constants_1.TARGET_FRAMEWORK_IDENTIFIERS.Cordova.toLowerCase():
                    return this.getCordovaPortInformation(abstractPortsInformation, appIdentifier, processId);
                case constants_1.TARGET_FRAMEWORK_IDENTIFIERS.NativeScript.toLowerCase():
                    return this.getNativeScriptPortInformation(abstractPortsInformation, appIdentifier);
                default:
                    return this.getCordovaPortInformation(abstractPortsInformation, appIdentifier, processId) ||
                        this.getNativeScriptPortInformation(abstractPortsInformation, appIdentifier);
            }
        }).future()();
    }
    getCordovaPortInformation(abstractPortsInformation, appIdentifier, processId) {
        return this.getPortInformation(abstractPortsInformation, `${appIdentifier}_devtools_remote`) || this.getPortInformation(abstractPortsInformation, processId);
    }
    getNativeScriptPortInformation(abstractPortsInformation, appIdentifier) {
        return this.getPortInformation(abstractPortsInformation, `${appIdentifier}-debug`);
    }
    getAbstractPortsInformation(adb) {
        return adb.executeShellCommand(["cat", "/proc/net/unix"]);
    }
    getPortInformation(abstractPortsInformation, searchedInfo) {
        let processRegExp = new RegExp(`\\w+:\\s+(?:\\w+\\s+){1,6}@(.*?${searchedInfo})$`, "gm");
        let match = processRegExp.exec(abstractPortsInformation);
        return match && match[1];
    }
    getProcessIds(adb, appIdentifiers) {
        return (() => {
            let result = {};
            let processIdInformation = adb.executeShellCommand(["ps"]).wait();
            _.each(appIdentifiers, appIdentifier => {
                let processIdRegExp = new RegExp(`^\\w*\\s*(\\d+).*?${appIdentifier}$`);
                result[appIdentifier] = this.getFirstMatchingGroupFromMultilineResult(processIdInformation, processIdRegExp);
            });
            return result;
        }).future()();
    }
    getAlreadyMappedPort(adb, deviceIdentifier, abstractPort, adbForwardList) {
        return (() => {
            let allForwardedPorts = adbForwardList || adb.executeCommand(["forward", "--list"]).wait() || "";
            let regex = new RegExp(`${deviceIdentifier}\\s+?tcp:(\\d+?)\\s+?.*?${abstractPort}$`);
            return this.getFirstMatchingGroupFromMultilineResult(allForwardedPorts, regex);
        }).future()();
    }
    getAdb(deviceIdentifier) {
        if (!this._devicesAdbs[deviceIdentifier]) {
            this._devicesAdbs[deviceIdentifier] = this.$injector.resolve(device_android_debug_bridge_1.DeviceAndroidDebugBridge, { identifier: deviceIdentifier });
        }
        return this._devicesAdbs[deviceIdentifier];
    }
    getApplicationIdentifierFromPid(adb, pid, psData) {
        return (() => {
            psData = psData || adb.executeShellCommand(["ps"]).wait();
            return this.getFirstMatchingGroupFromMultilineResult(psData, new RegExp(`\\s+${pid}(?:\\s+\\d+){3}\\s+.*\\s+(.*?)$`));
        }).future()();
    }
    getFirstMatchingGroupFromMultilineResult(input, regex) {
        let result;
        _((input || "").split('\n'))
            .map(line => line.trim())
            .filter(line => !!line)
            .each(line => {
            let matches = line.match(regex);
            if (matches && matches[1]) {
                result = matches[1];
                return false;
            }
        });
        return result;
    }
    tryAttachToProcessExitSignals() {
        this.$processService.attachToProcessExitSignals(this, () => {
            _.each(this._forwardedLocalPorts, (port) => {
                shelljs.exec(`adb forward --remove tcp:${port}`);
            });
        });
    }
}
exports.AndroidProcessService = AndroidProcessService;
$injector.register("androidProcessService", AndroidProcessService);
