"use strict";
const uuid = require("uuid");
const Fiber = require("fibers");
let Table = require("cli-table");
const Future = require("fibers/future");
const os_1 = require("os");
function settlePromises(promises) {
    return new Promise((resolve, reject) => {
        let settledPromisesCount = 0, results = [], errors = [];
        const length = promises.length;
        _.forEach(promises, currentPromise => {
            currentPromise
                .then(result => {
                results.push(result);
            })
                .catch(err => {
                errors.push(err);
            })
                .then(() => {
                settledPromisesCount++;
                if (settledPromisesCount === length) {
                    errors.length ? reject(new Error(`Multiple errors were thrown:${os_1.EOL}${errors.map(e => e.message || e).join(os_1.EOL)}`)) : resolve(results);
                }
            });
        });
    });
}
exports.settlePromises = settlePromises;
function getPropertyName(func) {
    if (func) {
        let match = func.toString().match(/(?:return\s+?.*\.(.+);)|(?:=>\s*?.*\.(.+)\b)/);
        if (match) {
            return (match[1] || match[2]).trim();
        }
    }
    return null;
}
exports.getPropertyName = getPropertyName;
function bashQuote(s) {
    if (s[0] === "'" && s[s.length - 1] === "'") {
        return s;
    }
    return "'" + s.replace(/'/g, '\'"\'"\'') + "'";
}
function cmdQuote(s) {
    if (s[0] === '"' && s[s.length - 1] === '"') {
        return s;
    }
    return '"' + s.replace(/"/g, '\\"') + '"';
}
function quoteString(s) {
    if (!s) {
        return s;
    }
    return (os_1.platform() === "win32") ? cmdQuote(s) : bashQuote(s);
}
exports.quoteString = quoteString;
function createGUID(useBraces) {
    let output;
    useBraces = useBraces === undefined ? true : useBraces;
    if (useBraces) {
        output = "{" + uuid.v4() + "}";
    }
    else {
        output = uuid.v4();
    }
    return output;
}
exports.createGUID = createGUID;
function stringReplaceAll(string, find, replace) {
    return string.split(find).join(replace);
}
exports.stringReplaceAll = stringReplaceAll;
function isRequestSuccessful(request) {
    return request.statusCode >= 200 && request.statusCode < 300;
}
exports.isRequestSuccessful = isRequestSuccessful;
function isResponseRedirect(response) {
    return _.includes([301, 302, 303, 307, 308], response.statusCode);
}
exports.isResponseRedirect = isResponseRedirect;
function formatListOfNames(names, conjunction) {
    conjunction = conjunction === undefined ? "or" : conjunction;
    if (names.length <= 1) {
        return names[0];
    }
    else {
        return _.initial(names).join(", ") + " " + conjunction + " " + names[names.length - 1];
    }
}
exports.formatListOfNames = formatListOfNames;
function getRelativeToRootPath(rootPath, filePath) {
    let relativeToRootPath = filePath.substr(rootPath.length);
    return relativeToRootPath;
}
exports.getRelativeToRootPath = getRelativeToRootPath;
function getVersionArray(version) {
    let result = [], parseLambda = (x) => parseInt(x, 10), filterLambda = (x) => !isNaN(x);
    if (typeof version === "string") {
        let versionString = version.split("-")[0];
        result = _.map(versionString.split("."), parseLambda);
    }
    else {
        result = _(version).map(parseLambda).filter(filterLambda).value();
    }
    return result;
}
function versionCompare(version1, version2) {
    let v1array = getVersionArray(version1), v2array = getVersionArray(version2);
    if (v1array.length !== v2array.length) {
        throw new Error("Version strings are not in the same format");
    }
    for (let i = 0; i < v1array.length; ++i) {
        if (v1array[i] !== v2array[i]) {
            return v1array[i] > v2array[i] ? 1 : -1;
        }
    }
    return 0;
}
exports.versionCompare = versionCompare;
function isInteractive() {
    return process.stdout.isTTY && process.stdin.isTTY;
}
exports.isInteractive = isInteractive;
function toBoolean(str) {
    return !!(str && str.toString && str.toString().toLowerCase() === "true");
}
exports.toBoolean = toBoolean;
function block(operation) {
    if (isInteractive()) {
        process.stdin.setRawMode(false);
    }
    operation();
    if (isInteractive()) {
        process.stdin.setRawMode(true);
    }
}
exports.block = block;
function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}
exports.isNumber = isNumber;
function fromWindowsRelativePathToUnix(windowsRelativePath) {
    return windowsRelativePath.replace(/\\/g, "/");
}
exports.fromWindowsRelativePathToUnix = fromWindowsRelativePathToUnix;
function isNullOrWhitespace(input) {
    if (!input && input !== false) {
        return true;
    }
    return _.isString(input) && input.replace(/\s/gi, "").length < 1;
}
exports.isNullOrWhitespace = isNullOrWhitespace;
function getCurrentEpochTime() {
    let dateTime = new Date();
    return dateTime.getTime();
}
exports.getCurrentEpochTime = getCurrentEpochTime;
function sleep(ms) {
    let fiber = Fiber.current;
    setTimeout(() => fiber.run(), ms);
    Fiber.yield();
}
exports.sleep = sleep;
function createTable(headers, data) {
    let table = new Table({
        head: headers,
        chars: { "mid": "", "left-mid": "", "mid-mid": "", "right-mid": "" }
    });
    _.forEach(data, row => table.push(row));
    return table;
}
exports.createTable = createTable;
function remove(array, predicate, numberOfElements) {
    numberOfElements = numberOfElements || 1;
    let index = _.findIndex(array, predicate);
    if (index === -1) {
        return new Array();
    }
    return array.splice(index, numberOfElements);
}
exports.remove = remove;
function trimSymbol(str, symbol) {
    while (str.charAt(0) === symbol) {
        str = str.substr(1);
    }
    while (str.charAt(str.length - 1) === symbol) {
        str = str.substr(0, str.length - 1);
    }
    return str;
}
exports.trimSymbol = trimSymbol;
function getFuturesResults(futures, predicate) {
    Future.wait(futures);
    return _(futures)
        .map(f => f.get())
        .filter(predicate)
        .flatten()
        .value();
}
exports.getFuturesResults = getFuturesResults;
function appendZeroesToVersion(version, requiredVersionLength) {
    let zeroesToAppend = requiredVersionLength - version.split(".").length;
    for (let index = 0; index < zeroesToAppend; index++) {
        version += ".0";
    }
    return version;
}
exports.appendZeroesToVersion = appendZeroesToVersion;
function decorateMethod(before, after) {
    return (target, propertyKey, descriptor) => {
        let sink = descriptor.value;
        descriptor.value = function (...args) {
            if (before) {
                before(sink, this, args);
            }
            let result = sink.apply(this, args);
            if (after) {
                return after(sink, this, result, args);
            }
            return result;
        };
    };
}
exports.decorateMethod = decorateMethod;
function hook(commandName) {
    function getHooksService(self) {
        let hooksService = self.$hooksService;
        if (!hooksService) {
            let injector = self.$injector;
            if (!injector) {
                throw Error('Type with hooks needs to have either $hooksService or $injector injected.');
            }
            hooksService = injector.resolve('hooksService');
        }
        return hooksService;
    }
    function prepareArguments(method, args, hooksService) {
        annotate(method);
        let argHash = {};
        for (let i = 0; i < method.$inject.args.length; ++i) {
            argHash[method.$inject.args[i]] = args[i];
        }
        argHash.$arguments = args;
        let result = {};
        result[hooksService.hookArgsName] = argHash;
        return result;
    }
    return decorateMethod((method, self, args) => {
        let hooksService = getHooksService(self);
        hooksService.executeBeforeHooks(commandName, prepareArguments(method, args, hooksService)).wait();
    }, (method, self, resultPromise, args) => {
        let result = resultPromise.wait();
        let hooksService = getHooksService(self);
        hooksService.executeAfterHooks(commandName, prepareArguments(method, args, hooksService)).wait();
        return Future.fromResult(result);
    });
}
exports.hook = hook;
function isFuture(candidateFuture) {
    return !!(candidateFuture && typeof (candidateFuture.wait) === "function");
}
exports.isFuture = isFuture;
function whenAny(...futures) {
    let resultFuture = new Future();
    let futuresLeft = futures.length;
    _.each(futures, future => {
        future.resolve((error, result) => {
            futuresLeft--;
            if (!resultFuture.isResolved()) {
                if (typeof error === "undefined") {
                    resultFuture.return(future);
                }
                else if (futuresLeft === 0) {
                    resultFuture.throw(new Error("None of the futures succeeded."));
                }
            }
        });
    });
    return resultFuture;
}
exports.whenAny = whenAny;
function connectEventually(factory, handler) {
    function tryConnect() {
        let tryConnectAfterTimeout = setTimeout.bind(undefined, tryConnect, 1000);
        let socket = factory();
        socket.on("connect", () => {
            socket.removeListener("error", tryConnectAfterTimeout);
            handler(socket);
        });
        socket.on("error", tryConnectAfterTimeout);
    }
    tryConnect();
}
exports.connectEventually = connectEventually;
function connectEventuallyUntilTimeout(factory, timeout) {
    let future = new Future();
    let lastKnownError;
    setTimeout(function () {
        if (!future.isResolved()) {
            future.throw(lastKnownError);
        }
    }, timeout);
    function tryConnect() {
        let tryConnectAfterTimeout = (error) => {
            if (future.isResolved()) {
                return;
            }
            lastKnownError = error;
            setTimeout(tryConnect, 1000);
        };
        let socket = factory();
        socket.on("connect", () => {
            socket.removeListener("error", tryConnectAfterTimeout);
            future.return(socket);
        });
        socket.on("error", tryConnectAfterTimeout);
    }
    tryConnect();
    return future;
}
exports.connectEventuallyUntilTimeout = connectEventuallyUntilTimeout;
const CLASS_NAME = /class\s+([A-Z].+?)(?:\s+.*?)?\{/;
const CONSTRUCTOR_ARGS = /constructor\s*([^\(]*)\(\s*([^\)]*)\)/m;
const FN_NAME_AND_ARGS = /^(?:function)?\s*([^\(]*)\(\s*([^\)]*)\)\s*(=>)?\s*\{/m;
const FN_ARG_SPLIT = /,/;
const FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
function annotate(fn) {
    let $inject, fnText, argDecl;
    if (typeof fn === "function") {
        if (!($inject = fn.$inject) || $inject.name !== fn.name) {
            $inject = { args: [], name: "" };
            fnText = fn.toString().replace(STRIP_COMMENTS, '');
            let nameMatch = fnText.match(CLASS_NAME);
            if (nameMatch) {
                argDecl = fnText.match(CONSTRUCTOR_ARGS);
            }
            else {
                nameMatch = argDecl = fnText.match(FN_NAME_AND_ARGS);
            }
            $inject.name = nameMatch && nameMatch[1];
            if (argDecl && fnText.length) {
                argDecl[2].split(FN_ARG_SPLIT).forEach((arg) => {
                    arg.replace(FN_ARG, (all, underscore, name) => $inject.args.push(name));
                });
            }
            fn.$inject = $inject;
        }
    }
    return $inject;
}
exports.annotate = annotate;
