"use strict";
const device_android_debug_bridge_1 = require("../../common/mobile/android/device-android-debug-bridge");
const android_device_hash_service_1 = require("../../common/mobile/android/android-device-hash-service");
const Future = require("fibers/future");
const helpers = require("../../common/helpers");
const path = require("path");
const net = require("net");
class AndroidLiveSyncService {
    constructor(_device, $fs, $mobileHelper, $options, $injector, $projectData, $androidDebugService, $liveSyncProvider) {
        this.$fs = $fs;
        this.$mobileHelper = $mobileHelper;
        this.$options = $options;
        this.$injector = $injector;
        this.$projectData = $projectData;
        this.$androidDebugService = $androidDebugService;
        this.$liveSyncProvider = $liveSyncProvider;
        this.device = (_device);
    }
    get debugService() {
        return this.$androidDebugService;
    }
    refreshApplication(deviceAppData, localToDevicePaths, forceExecuteFullSync) {
        let canExecuteFastSync = !forceExecuteFullSync && !_.some(localToDevicePaths, (localToDevicePath) => !this.$liveSyncProvider.canExecuteFastSync(localToDevicePath.getLocalPath(), deviceAppData.platform));
        if (canExecuteFastSync) {
            return this.reloadPage(deviceAppData, localToDevicePaths);
        }
        return this.restartApplication(deviceAppData);
    }
    restartApplication(deviceAppData) {
        return (() => {
            this.device.adb.executeShellCommand(["chmod", "777", deviceAppData.deviceProjectRootPath, `/data/local/tmp/${deviceAppData.appIdentifier}`]).wait();
            let devicePathRoot = `/data/data/${deviceAppData.appIdentifier}/files`;
            let devicePath = this.$mobileHelper.buildDevicePath(devicePathRoot, "code_cache", "secondary_dexes", "proxyThumb");
            this.device.adb.executeShellCommand(["rm", "-rf", devicePath]).wait();
            this.device.applicationManager.restartApplication(deviceAppData.appIdentifier).wait();
        }).future()();
    }
    beforeLiveSyncAction(deviceAppData) {
        return (() => {
            let deviceRootPath = this.getDeviceRootPath(deviceAppData.appIdentifier), deviceRootDir = path.dirname(deviceRootPath), deviceRootBasename = path.basename(deviceRootPath), listResult = this.device.adb.executeShellCommand(["ls", "-l", deviceRootDir]).wait(), regex = new RegExp(`^-.*${deviceRootBasename}$`, "m"), matchingFile = (listResult || "").match(regex);
            if (matchingFile && matchingFile[0] && _.startsWith(matchingFile[0], '-')) {
                this.device.adb.executeShellCommand(["rm", "-f", deviceRootPath]).wait();
            }
            this.device.adb.executeShellCommand(["rm", "-rf", this.$mobileHelper.buildDevicePath(deviceRootPath, "fullsync"),
                this.$mobileHelper.buildDevicePath(deviceRootPath, "sync"),
                this.$mobileHelper.buildDevicePath(deviceRootPath, "removedsync")]).wait();
        }).future()();
    }
    reloadPage(deviceAppData, localToDevicePaths) {
        return (() => {
            this.device.adb.executeCommand(["forward", `tcp:${AndroidLiveSyncService.BACKEND_PORT.toString()}`, `localabstract:${deviceAppData.appIdentifier}-livesync`]).wait();
            if (!this.sendPageReloadMessage().wait()) {
                this.restartApplication(deviceAppData).wait();
            }
        }).future()();
    }
    removeFiles(appIdentifier, localToDevicePaths) {
        return (() => {
            let deviceRootPath = this.getDeviceRootPath(appIdentifier);
            _.each(localToDevicePaths, localToDevicePathData => {
                let relativeUnixPath = _.trimStart(helpers.fromWindowsRelativePathToUnix(localToDevicePathData.getRelativeToProjectBasePath()), "/");
                let deviceFilePath = this.$mobileHelper.buildDevicePath(deviceRootPath, "removedsync", relativeUnixPath);
                this.device.adb.executeShellCommand(["mkdir", "-p", path.dirname(deviceFilePath), "&&", "touch", deviceFilePath]).wait();
            });
            this.deviceHashService.removeHashes(localToDevicePaths).wait();
        }).future()();
    }
    afterInstallApplicationAction(deviceAppData, localToDevicePaths) {
        return (() => {
            this.deviceHashService.uploadHashFileToDevice(localToDevicePaths).wait();
            return false;
        }).future()();
    }
    getDeviceRootPath(appIdentifier) {
        return `/data/local/tmp/${appIdentifier}`;
    }
    sendPageReloadMessage() {
        let future = new Future();
        let socket = new net.Socket();
        socket.connect(AndroidLiveSyncService.BACKEND_PORT, '127.0.0.1', () => {
            socket.write(new Buffer([0, 0, 0, 1, 1]));
        });
        socket.on("data", (data) => {
            socket.destroy();
            future.return(true);
        });
        socket.on("error", () => {
            if (!future.isResolved()) {
                future.return(false);
            }
        });
        socket.on("close", () => {
            if (!future.isResolved()) {
                future.return(false);
            }
        });
        return future;
    }
    get deviceHashService() {
        if (!this._deviceHashService) {
            let adb = this.$injector.resolve(device_android_debug_bridge_1.DeviceAndroidDebugBridge, { identifier: this.device.deviceInfo.identifier });
            this._deviceHashService = this.$injector.resolve(android_device_hash_service_1.AndroidDeviceHashService, { adb: adb, appIdentifier: this.$projectData.projectId });
        }
        return this._deviceHashService;
    }
}
AndroidLiveSyncService.BACKEND_PORT = 18182;
$injector.register("androidLiveSyncServiceLocator", { factory: AndroidLiveSyncService });
