"use strict";
const helpers_1 = require("../../common/helpers");
const constants_1 = require("../../constants");
const Future = require("fibers/future");
class FindPluginsCommand {
    constructor($pluginsService, $errors, $logger, $prompter, $options, $progressIndicator) {
        this.$pluginsService = $pluginsService;
        this.$errors = $errors;
        this.$logger = $logger;
        this.$prompter = $prompter;
        this.$options = $options;
        this.$progressIndicator = $progressIndicator;
        this.allowedParameters = [];
    }
    execute(args) {
        return (() => {
            let filter = this.prepareFilter(args);
            let pluginsFuture = this.$pluginsService.getAvailable(filter);
            if (this.$options.json) {
                this.$logger.out(JSON.stringify(pluginsFuture.wait()));
                return;
            }
            this.$logger.printInfoMessageOnSameLine("Searching npm please be patient...");
            this.$progressIndicator.showProgressIndicator(pluginsFuture, 500).wait();
            let plugins = pluginsFuture.get();
            this.showPlugins(plugins).wait();
        }).future()();
    }
    canExecute(args) {
        return Future.fromResult(true);
    }
    showPlugins(plugins) {
        return (() => {
            let allPluginsNames = _.keys(plugins).sort();
            if (!allPluginsNames || !allPluginsNames.length) {
                this.$logger.warn("No plugins found.");
                return;
            }
            let count = this.$options.count || FindPluginsCommand.COUNT_OF_PLUGINS_TO_DISPLAY;
            if (!helpers_1.isInteractive() || this.$options.all) {
                count = allPluginsNames.length;
            }
            let data = [];
            let pluginsToDisplay = allPluginsNames.splice(0, count);
            let shouldDisplayMorePlugins = true;
            this.$logger.out("Available NativeScript plugins:");
            do {
                data = this.createTableCells(plugins, pluginsToDisplay);
                let table = this.createPluginsTable(data);
                this.$logger.out(table.toString());
                pluginsToDisplay = allPluginsNames.splice(0, count);
                if (!pluginsToDisplay || pluginsToDisplay.length < 1) {
                    return;
                }
                shouldDisplayMorePlugins = this.$prompter.confirm("Load more plugins?").wait();
            } while (shouldDisplayMorePlugins);
        }).future()();
    }
    createPluginsTable(data) {
        let headers = ["Plugin", "Version", "Description"];
        let table = helpers_1.createTable(headers, data);
        return table;
    }
    createTableCells(plugins, pluginsToDisplay) {
        return pluginsToDisplay.map(pluginName => {
            let pluginDetails = plugins[pluginName];
            return [pluginName, pluginDetails.version, pluginDetails.description || ""];
        });
    }
    prepareFilter(args) {
        return _(args || [])
            .map(arg => arg.toLowerCase())
            .concat(constants_1.NATIVESCRIPT_KEY_NAME)
            .uniq()
            .value();
    }
}
FindPluginsCommand.COUNT_OF_PLUGINS_TO_DISPLAY = 10;
exports.FindPluginsCommand = FindPluginsCommand;
$injector.registerCommand(["plugin|find", "plugin|search"], FindPluginsCommand);
