"use strict";
let jaroWinklerDistance = require("../vendor/jaro-winkler_distance");
const helpers = require("../helpers");
const os_1 = require("os");
class CommandArgumentsValidationHelper {
    constructor(isValid, _remainingArguments) {
        this.isValid = isValid;
        this.remainingArguments = _remainingArguments.slice();
    }
}
class CommandsService {
    constructor($commandsServiceProvider, $errors, $fs, $hooksService, $injector, $logger, $options, $resources, $staticConfig) {
        this.$commandsServiceProvider = $commandsServiceProvider;
        this.$errors = $errors;
        this.$fs = $fs;
        this.$hooksService = $hooksService;
        this.$injector = $injector;
        this.$logger = $logger;
        this.$options = $options;
        this.$resources = $resources;
        this.$staticConfig = $staticConfig;
        this.areDynamicSubcommandsRegistered = false;
        this.cachedCommandHelp = null;
    }
    allCommands(opts) {
        let commands = this.$injector.getRegisteredCommandsNames(opts.includeDevCommands);
        return _.reject(commands, (command) => _.includes(command, '|'));
    }
    executeCommandUnchecked(commandName, commandArguments) {
        return (() => {
            let command = this.$injector.resolveCommand(commandName);
            if (command) {
                if (!this.$staticConfig.disableAnalytics && !command.disableAnalytics) {
                    let analyticsService = this.$injector.resolve("analyticsService");
                    analyticsService.checkConsent().wait();
                    analyticsService.trackFeature(commandName).wait();
                }
                if (!this.$staticConfig.disableCommandHooks && (command.enableHooks === undefined || command.enableHooks === true)) {
                    let hierarchicalCommandName = this.$injector.buildHierarchicalCommand(commandName, commandArguments);
                    if (hierarchicalCommandName) {
                        commandName = helpers.stringReplaceAll(hierarchicalCommandName.commandName, CommandsService.HIERARCHICAL_COMMANDS_DEFAULT_COMMAND_DELIMITER, CommandsService.HOOKS_COMMANDS_DELIMITER);
                        commandName = helpers.stringReplaceAll(commandName, CommandsService.HIERARCHICAL_COMMANDS_DELIMITER, CommandsService.HOOKS_COMMANDS_DELIMITER);
                    }
                    this.$hooksService.executeBeforeHooks(commandName).wait();
                    command.execute(commandArguments).wait();
                    this.$hooksService.executeAfterHooks(commandName).wait();
                }
                else {
                    command.execute(commandArguments).wait();
                }
                let commandHelp = this.getCommandHelp();
                if (!command.disableCommandHelpSuggestion && commandHelp && commandHelp[commandName]) {
                    let suggestionText = commandHelp[commandName];
                    this.$logger.printMarkdown(~suggestionText.indexOf('%s') ? require('util').format(suggestionText, commandArguments) : suggestionText);
                }
                return true;
            }
            return false;
        }).future()();
    }
    printHelp(commandName) {
        this.$options.help = true;
        return this.executeCommandUnchecked("help", [this.beautifyCommandName(commandName)]);
    }
    executeCommandAction(commandName, commandArguments, action) {
        return this.$errors.beginCommand(() => action.apply(this, [commandName, commandArguments]), () => this.printHelp(commandName));
    }
    tryExecuteCommandAction(commandName, commandArguments) {
        let command = this.$injector.resolveCommand(commandName);
        this.$options.validateOptions(command ? command.dashedOptions : null);
        if (!this.areDynamicSubcommandsRegistered) {
            this.$commandsServiceProvider.registerDynamicSubCommands();
            this.areDynamicSubcommandsRegistered = true;
        }
        return this.canExecuteCommand(commandName, commandArguments);
    }
    tryExecuteCommand(commandName, commandArguments) {
        return (() => {
            if (this.executeCommandAction(commandName, commandArguments, this.tryExecuteCommandAction).wait()) {
                this.executeCommandAction(commandName, commandArguments, this.executeCommandUnchecked).wait();
            }
            else {
                let command = this.$injector.resolveCommand(commandName);
                if (command) {
                    this.printHelp(commandName).wait();
                }
            }
        }).future()();
    }
    canExecuteCommand(commandName, commandArguments, isDynamicCommand) {
        return (() => {
            let command = this.$injector.resolveCommand(commandName);
            let beautifiedName = helpers.stringReplaceAll(commandName, "|", " ");
            if (command) {
                if (command.isDisabled) {
                    this.$errors.failWithoutHelp("This command is not applicable to your environment.");
                }
                if (command.canExecute) {
                    return command.canExecute(commandArguments).wait();
                }
                if (this.$injector.isValidHierarchicalCommand(commandName, commandArguments)) {
                    return true;
                }
                if (this.validateCommandArguments(command, commandArguments).wait()) {
                    return true;
                }
                this.$errors.fail("Unable to execute command '%s'. Use '$ %s %s --help' for help.", beautifiedName, this.$staticConfig.CLIENT_NAME.toLowerCase(), beautifiedName);
                return false;
            }
            else if (!isDynamicCommand && _.startsWith(commandName, this.$commandsServiceProvider.dynamicCommandsPrefix)) {
                if (_.some(this.$commandsServiceProvider.getDynamicCommands().wait())) {
                    this.$commandsServiceProvider.generateDynamicCommands().wait();
                    return this.canExecuteCommand(commandName, commandArguments, true).wait();
                }
            }
            this.$logger.fatal("Unknown command '%s'. Use '%s help' for help.", beautifiedName, this.$staticConfig.CLIENT_NAME.toLowerCase());
            this.tryMatchCommand(commandName);
            return false;
        }).future()();
    }
    validateMandatoryParams(commandArguments, mandatoryParams) {
        return (() => {
            let commandArgsHelper = new CommandArgumentsValidationHelper(true, commandArguments);
            if (mandatoryParams.length > 0) {
                if (mandatoryParams.length > commandArguments.length) {
                    let customErrorMessages = _.map(mandatoryParams, mp => mp.errorMessage);
                    customErrorMessages.splice(0, 0, "You need to provide all the required parameters.");
                    this.$errors.fail(customErrorMessages.join(os_1.EOL));
                }
                _.each(mandatoryParams, (mandatoryParam) => {
                    let argument = _.find(commandArgsHelper.remainingArguments, c => mandatoryParam.validate(c).wait());
                    if (argument) {
                        helpers.remove(commandArgsHelper.remainingArguments, arg => arg === argument);
                    }
                    else {
                        this.$errors.fail("Missing mandatory parameter.");
                    }
                });
            }
            return commandArgsHelper;
        }).future()();
    }
    validateCommandArguments(command, commandArguments) {
        return (() => {
            let mandatoryParams = _.filter(command.allowedParameters, (param) => param.mandatory);
            let commandArgsHelper = this.validateMandatoryParams(commandArguments, mandatoryParams).wait();
            if (!commandArgsHelper.isValid) {
                return false;
            }
            if (!command.allowedParameters || command.allowedParameters.length === 0) {
                if (commandArguments.length > 0) {
                    this.$errors.fail("This command doesn't accept parameters.");
                }
            }
            else {
                let unverifiedAllowedParams = command.allowedParameters.filter((param) => !param.mandatory);
                _.each(commandArgsHelper.remainingArguments, (argument) => {
                    let parameter = _.find(unverifiedAllowedParams, (c) => c.validate(argument).wait());
                    if (parameter) {
                        let index = unverifiedAllowedParams.indexOf(parameter);
                        unverifiedAllowedParams.splice(index, 1);
                    }
                    else {
                        this.$errors.fail("The parameter %s is not valid for this command.", argument);
                    }
                });
            }
            return true;
        }).future()();
    }
    tryMatchCommand(commandName) {
        let allCommands = this.allCommands({ includeDevCommands: false });
        let similarCommands = [];
        _.each(allCommands, (command) => {
            if (!this.$injector.isDefaultCommand(command)) {
                command = helpers.stringReplaceAll(command, "|", " ");
                let distance = jaroWinklerDistance(commandName, command);
                if (commandName.length > 3 && command.indexOf(commandName) !== -1) {
                    similarCommands.push({ rating: 1, name: command });
                }
                else if (distance >= 0.65) {
                    similarCommands.push({ rating: distance, name: command });
                }
            }
        });
        similarCommands = _.sortBy(similarCommands, (command) => {
            return -command.rating;
        }).slice(0, 5);
        if (similarCommands.length > 0) {
            let message = ["Did you mean?"];
            _.each(similarCommands, (command) => {
                message.push("\t" + command.name);
            });
            this.$logger.fatal(message.join("\n"));
        }
    }
    completeCommand() {
        return (() => {
            let tabtab = require("tabtab");
            let completeCallback = (err, data) => {
                if (err || !data) {
                    return;
                }
                let commands = this.$injector.getRegisteredCommandsNames(false);
                let splittedLine = data.line.split(/[ ]+/);
                let line = _.filter(splittedLine, (w) => w !== "");
                let commandName = (line[line.length - 2]);
                let childrenCommands = this.$injector.getChildrenCommandsNames(commandName);
                if (data.last && _.startsWith(data.last, "--")) {
                    return tabtab.log(_.keys(this.$options.options), data, "--");
                }
                if (data.last && _.startsWith(data.last, "-")) {
                    return tabtab.log(this.$options.shorthands, data, "-");
                }
                if (data.words === 1) {
                    let allCommands = this.allCommands({ includeDevCommands: false });
                    if (_.startsWith(data.last, this.$commandsServiceProvider.dynamicCommandsPrefix)) {
                        allCommands = allCommands.concat(this.$commandsServiceProvider.getDynamicCommands().wait());
                    }
                    return tabtab.log(allCommands, data);
                }
                if (data.words >= 2) {
                    if (data.words !== line.length) {
                        commandName = `${line[data.words - 2]}|${line[data.words - 1]}`;
                    }
                    else {
                        commandName = `${line[line.length - 1]}`;
                    }
                }
                let command = this.$injector.resolveCommand(commandName);
                if (command) {
                    let completionData = command.completionData;
                    if (completionData) {
                        return tabtab.log(completionData, data);
                    }
                    else {
                        return this.logChildrenCommandsNames(commandName, commands, tabtab, data);
                    }
                }
                else if (childrenCommands) {
                    let nonDefaultSubCommands = _.reject(childrenCommands, (children) => children[0] === '*');
                    let sanitizedChildrenCommands = [];
                    if (data.words !== line.length) {
                        sanitizedChildrenCommands = nonDefaultSubCommands.map((commandToMap) => {
                            let pipePosition = commandToMap.indexOf("|");
                            return commandToMap.substring(0, pipePosition !== -1 ? pipePosition : commandToMap.length);
                        });
                    }
                    else {
                        nonDefaultSubCommands = nonDefaultSubCommands.filter((commandNameToFilter) => commandNameToFilter.indexOf("|") !== -1);
                        sanitizedChildrenCommands = nonDefaultSubCommands.map((commandToMap) => {
                            let pipePosition = commandToMap.lastIndexOf("|");
                            return commandToMap.substring(pipePosition !== -1 ? pipePosition + 1 : 0, commandToMap.length);
                        });
                    }
                    return tabtab.log(sanitizedChildrenCommands, data);
                }
                else {
                    return this.logChildrenCommandsNames(commandName, commands, tabtab, data);
                }
            };
            tabtab.complete(this.$staticConfig.CLIENT_NAME.toLowerCase(), completeCallback);
            if (this.$staticConfig.CLIENT_NAME_ALIAS) {
                tabtab.complete(this.$staticConfig.CLIENT_NAME_ALIAS.toLowerCase(), completeCallback);
            }
            return true;
        }).future()();
    }
    getCommandHelp() {
        if (!this.cachedCommandHelp && this.$fs.exists(this.$resources.resolvePath(this.$staticConfig.COMMAND_HELP_FILE_NAME))) {
            this.cachedCommandHelp = this.$resources.readJson(this.$staticConfig.COMMAND_HELP_FILE_NAME);
        }
        return this.cachedCommandHelp;
    }
    beautifyCommandName(commandName) {
        if (commandName.indexOf("*") > 0) {
            return commandName.substr(0, commandName.indexOf("|"));
        }
        return commandName;
    }
    logChildrenCommandsNames(commandName, commands, tabtab, data) {
        let matchingCommands = commands.filter((commandToFilter) => {
            return commandToFilter.indexOf(commandName + "|") !== -1 && commandToFilter !== commandName;
        })
            .map((commandToMap) => {
            let commandResult = commandToMap.replace(commandName + "|", "");
            return commandResult.substring(0, commandResult.indexOf("|") !== -1 ? commandResult.indexOf("|") : commandResult.length);
        });
        return tabtab.log(matchingCommands, data);
    }
}
CommandsService.HIERARCHICAL_COMMANDS_DELIMITER = "|";
CommandsService.HIERARCHICAL_COMMANDS_DEFAULT_COMMAND_DELIMITER = "|*";
CommandsService.HOOKS_COMMANDS_DELIMITER = "-";
exports.CommandsService = CommandsService;
$injector.register("commandsService", CommandsService);
