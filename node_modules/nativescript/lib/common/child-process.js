"use strict";
const Future = require("fibers/future");
const child_process = require("child_process");
class ChildProcess {
    constructor($logger, $errors) {
        this.$logger = $logger;
        this.$errors = $errors;
    }
    exec(command, options, execOptions) {
        let future = new Future();
        let callback = (error, stdout, stderr) => {
            this.$logger.trace("Exec %s \n stdout: %s \n stderr: %s", command, stdout.toString(), stderr.toString());
            if (error) {
                future.throw(error);
            }
            else {
                let output = execOptions && execOptions.showStderr ? { stdout, stderr } : stdout;
                future.return(output);
            }
        };
        if (options) {
            child_process.exec(command, options, callback);
        }
        else {
            child_process.exec(command, callback);
        }
        return future;
    }
    execFile(command, args) {
        this.$logger.debug("execFile: %s %s", command, this.getArgumentsAsQuotedString(args));
        let future = new Future();
        child_process.execFile(command, args, (error, stdout) => {
            if (error) {
                future.throw(error);
            }
            else {
                future.return(stdout);
            }
        });
        return future;
    }
    spawn(command, args, options) {
        this.$logger.debug("spawn: %s %s", command, this.getArgumentsAsQuotedString(args));
        return child_process.spawn(command, args, options);
    }
    fork(modulePath, args, options) {
        this.$logger.debug("fork: %s %s", modulePath, this.getArgumentsAsQuotedString(args));
        return child_process.fork(modulePath, args, options);
    }
    spawnFromEvent(command, args, event, options, spawnFromEventOptions) {
        let future = new Future();
        let childProcess = this.spawn(command, args, options);
        let capturedOut = "";
        let capturedErr = "";
        if (childProcess.stdout) {
            childProcess.stdout.on("data", (data) => {
                capturedOut += data;
            });
        }
        if (childProcess.stderr) {
            childProcess.stderr.on("data", (data) => {
                capturedErr += data;
            });
        }
        childProcess.on(event, (arg) => {
            let exitCode = typeof arg === "number" ? arg : arg && arg.code;
            let result = {
                stdout: capturedOut,
                stderr: capturedErr,
                exitCode: exitCode
            };
            if (spawnFromEventOptions && spawnFromEventOptions.throwError === false) {
                if (!future.isResolved()) {
                    this.$logger.trace("Result when throw error is false:");
                    this.$logger.trace(result);
                    future.return(result);
                }
            }
            else {
                if (exitCode === 0) {
                    future.return(result);
                }
                else {
                    let errorMessage = `Command ${command} failed with exit code ${exitCode}`;
                    if (capturedErr) {
                        errorMessage += ` Error output: \n ${capturedErr}`;
                    }
                    if (!future.isResolved()) {
                        future.throw(new Error(errorMessage));
                    }
                }
            }
        });
        childProcess.once("error", (err) => {
            if (!future.isResolved()) {
                if (spawnFromEventOptions && spawnFromEventOptions.throwError === false) {
                    let result = {
                        stdout: capturedOut,
                        stderr: err.message,
                        exitCode: err.code
                    };
                    future.return(result);
                }
                else {
                    future.throw(err);
                }
            }
        });
        return future;
    }
    tryExecuteApplication(command, args, event, errorMessage, condition) {
        return (() => {
            let childProcess = this.tryExecuteApplicationCore(command, args, event, errorMessage).wait();
            if (condition && condition(childProcess)) {
                this.$errors.fail(errorMessage);
            }
        }).future()();
    }
    tryExecuteApplicationCore(command, args, event, errorMessage) {
        try {
            return this.spawnFromEvent(command, args, event, undefined, { throwError: false });
        }
        catch (e) {
            let message = (e.code === "ENOENT") ? errorMessage : e.message;
            this.$errors.failWithoutHelp(message);
        }
    }
    getArgumentsAsQuotedString(args) {
        return args && args.length && args.map(argument => `"${argument}"`).join(" ");
    }
}
exports.ChildProcess = ChildProcess;
$injector.register("childProcess", ChildProcess);
