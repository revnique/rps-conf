"use strict";
const device_discovery_1 = require("./device-discovery");
const helpers = require("../../helpers");
const android_device_1 = require("../android/android-device");
const os_1 = require("os");
const Future = require("fibers/future");
const fiberBootstrap = require("../../fiber-bootstrap");
class AndroidDeviceDiscovery extends device_discovery_1.DeviceDiscovery {
    constructor($childProcess, $injector, $adb) {
        super();
        this.$childProcess = $childProcess;
        this.$injector = $injector;
        this.$adb = $adb;
        this._devices = [];
    }
    createAndAddDevice(adbDeviceInfo) {
        this._devices.push(adbDeviceInfo);
        let device = this.$injector.resolve(android_device_1.AndroidDevice, { identifier: adbDeviceInfo.identifier, status: adbDeviceInfo.status });
        this.addDevice(device);
    }
    deleteAndRemoveDevice(deviceIdentifier) {
        _.remove(this._devices, d => d.identifier === deviceIdentifier);
        this.removeDevice(deviceIdentifier);
    }
    startLookingForDevices() {
        return (() => {
            this.ensureAdbServerStarted().wait();
            let blockingFuture = new Future();
            this.checkForDevices(blockingFuture).wait();
        }).future()();
    }
    checkForDevices(future) {
        let adbData = "";
        let result = this.$adb.executeCommand(["devices"], { returnChildProcess: true }).wait();
        result.stdout.on("data", (data) => {
            adbData += data.toString();
        });
        result.stderr.on("data", (data) => {
            let error = new Error(data.toString());
            if (future && !future.isResolved()) {
                return future.throw(error);
            }
            else {
                throw (error);
            }
        });
        result.on("error", (err) => {
            if (future && !future.isResolved()) {
                return future.throw(err);
            }
            else {
                throw (err);
            }
        });
        result.on("close", (exitCode) => {
            fiberBootstrap.run(() => {
                this.checkCurrentData(adbData).wait();
                if (future && !future.isResolved()) {
                    future.return();
                }
            });
        });
        return future || Future.fromResult();
    }
    checkCurrentData(result) {
        return (() => {
            let currentDevices = result.toString().split(os_1.EOL).slice(1)
                .filter((element) => !helpers.isNullOrWhitespace(element))
                .map((element) => {
                let data = element.split('\t'), identifier = data[0], status = data[1];
                return {
                    identifier: identifier,
                    status: status
                };
            });
            _(this._devices)
                .reject(d => _.find(currentDevices, device => device.identifier === d.identifier && device.status === d.status))
                .each(d => this.deleteAndRemoveDevice(d.identifier));
            _(currentDevices)
                .reject(d => _.find(this._devices, device => device.identifier === d.identifier && device.status === d.status))
                .each(d => this.createAndAddDevice(d));
        }).future()();
    }
    ensureAdbServerStarted() {
        return (() => {
            if (!this.isStarted) {
                this.isStarted = true;
                try {
                    return this.$adb.executeCommand(["start-server"]).wait();
                }
                catch (err) {
                    this.isStarted = false;
                    throw err;
                }
            }
        }).future()();
    }
}
exports.AndroidDeviceDiscovery = AndroidDeviceDiscovery;
$injector.register("androidDeviceDiscovery", AndroidDeviceDiscovery);
