"use strict";
const events_1 = require("events");
const constants_1 = require("../constants");
class ApplicationManagerBase extends events_1.EventEmitter {
    constructor($logger, $hooksService) {
        super();
        this.$logger = $logger;
        this.$hooksService = $hooksService;
        this.lastAvailableDebuggableAppViews = {};
        this.isChecking = false;
    }
    reinstallApplication(appIdentifier, packageFilePath) {
        return (() => {
            this.uninstallApplication(appIdentifier).wait();
            this.installApplication(packageFilePath).wait();
        }).future()();
    }
    restartApplication(appIdentifier, bundleExecutable, framework) {
        return (() => {
            this.stopApplication(bundleExecutable || appIdentifier).wait();
            this.startApplication(appIdentifier, framework).wait();
        }).future()();
    }
    isApplicationInstalled(appIdentifier) {
        return (() => {
            if (!this.lastInstalledAppIdentifiers || !this.lastInstalledAppIdentifiers.length) {
                this.checkForApplicationUpdates().wait();
            }
            return _.includes(this.lastInstalledAppIdentifiers, appIdentifier);
        }).future()();
    }
    checkForApplicationUpdates() {
        return (() => {
            if (!this.isChecking) {
                try {
                    this.isChecking = true;
                    let currentlyInstalledAppIdentifiers = this.getInstalledApplications().wait();
                    let previouslyInstalledAppIdentifiers = this.lastInstalledAppIdentifiers || [];
                    let newAppIdentifiers = _.difference(currentlyInstalledAppIdentifiers, previouslyInstalledAppIdentifiers);
                    let removedAppIdentifiers = _.difference(previouslyInstalledAppIdentifiers, currentlyInstalledAppIdentifiers);
                    this.lastInstalledAppIdentifiers = currentlyInstalledAppIdentifiers;
                    _.each(newAppIdentifiers, appIdentifier => this.emit("applicationInstalled", appIdentifier));
                    _.each(removedAppIdentifiers, appIdentifier => this.emit("applicationUninstalled", appIdentifier));
                    this.checkForAvailableDebuggableAppsChanges().wait();
                }
                finally {
                    this.isChecking = false;
                }
            }
        }).future()();
    }
    tryStartApplication(appIdentifier, framework) {
        return (() => {
            try {
                if (this.canStartApplication()) {
                    this.startApplication(appIdentifier, framework).wait();
                }
            }
            catch (err) {
                this.$logger.trace(`Unable to start application ${appIdentifier}. Error is: ${err.message}`);
            }
        }).future()();
    }
    checkForAvailableDebuggableAppsChanges() {
        return (() => {
            let currentlyAvailableDebuggableApps = this.getDebuggableApps().wait();
            let previouslyAvailableDebuggableApps = this.lastAvailableDebuggableApps || [];
            let newAvailableDebuggableApps = _.differenceBy(currentlyAvailableDebuggableApps, previouslyAvailableDebuggableApps, "appIdentifier");
            let notAvailableAppsForDebugging = _.differenceBy(previouslyAvailableDebuggableApps, currentlyAvailableDebuggableApps, "appIdentifier");
            this.lastAvailableDebuggableApps = currentlyAvailableDebuggableApps;
            _.each(newAvailableDebuggableApps, (appInfo) => {
                this.emit("debuggableAppFound", appInfo);
            });
            _.each(notAvailableAppsForDebugging, (appInfo) => {
                this.emit("debuggableAppLost", appInfo);
                if (_.has(this.lastAvailableDebuggableAppViews, appInfo.appIdentifier)) {
                    delete this.lastAvailableDebuggableAppViews[appInfo.appIdentifier];
                }
            });
            let cordovaDebuggableAppIdentifiers = _(currentlyAvailableDebuggableApps)
                .filter(c => c.framework === constants_1.TARGET_FRAMEWORK_IDENTIFIERS.Cordova)
                .map(c => c.appIdentifier)
                .value();
            let currentlyAvailableAppViews = this.getDebuggableAppViews(cordovaDebuggableAppIdentifiers).wait();
            _.each(currentlyAvailableAppViews, (currentlyAvailableViews, appIdentifier) => {
                let previouslyAvailableViews = this.lastAvailableDebuggableAppViews[appIdentifier];
                let newAvailableViews = _.differenceBy(currentlyAvailableViews, previouslyAvailableViews, "id");
                let notAvailableViews = _.differenceBy(previouslyAvailableViews, currentlyAvailableViews, "id");
                _.each(notAvailableViews, debugWebViewInfo => {
                    this.emit("debuggableViewLost", appIdentifier, debugWebViewInfo);
                });
                _.each(newAvailableViews, debugWebViewInfo => {
                    this.emit("debuggableViewFound", appIdentifier, debugWebViewInfo);
                });
                let keptViews = _.differenceBy(currentlyAvailableViews, newAvailableViews, "id");
                _.each(keptViews, view => {
                    let previousTimeViewInfo = _.find(previouslyAvailableViews, previousView => previousView.id === view.id);
                    if (!_.isEqual(view, previousTimeViewInfo)) {
                        this.emit("debuggableViewChanged", appIdentifier, view);
                    }
                });
                this.lastAvailableDebuggableAppViews[appIdentifier] = currentlyAvailableViews;
            });
        }).future()();
    }
}
exports.ApplicationManagerBase = ApplicationManagerBase;
