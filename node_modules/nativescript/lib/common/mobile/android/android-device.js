"use strict";
const device_android_debug_bridge_1 = require("./device-android-debug-bridge");
const applicationManagerPath = require("./android-application-manager");
const fileSystemPath = require("./android-device-file-system");
const constants = require("../../constants");
class AndroidDevice {
    constructor(identifier, status, $androidEmulatorServices, $logger, $fs, $childProcess, $errors, $staticConfig, $devicePlatformsConstants, $options, $logcatHelper, $hostInfo, $mobileHelper, $injector) {
        this.identifier = identifier;
        this.status = status;
        this.$androidEmulatorServices = $androidEmulatorServices;
        this.$logger = $logger;
        this.$fs = $fs;
        this.$childProcess = $childProcess;
        this.$errors = $errors;
        this.$staticConfig = $staticConfig;
        this.$devicePlatformsConstants = $devicePlatformsConstants;
        this.$options = $options;
        this.$logcatHelper = $logcatHelper;
        this.$hostInfo = $hostInfo;
        this.$mobileHelper = $mobileHelper;
        this.$injector = $injector;
        this.adb = this.$injector.resolve(device_android_debug_bridge_1.DeviceAndroidDebugBridge, { identifier: this.identifier });
        this.applicationManager = this.$injector.resolve(applicationManagerPath.AndroidApplicationManager, { adb: this.adb, identifier: this.identifier });
        this.fileSystem = this.$injector.resolve(fileSystemPath.AndroidDeviceFileSystem, { adb: this.adb, identifier: this.identifier });
        let details;
        try {
            details = this.getDeviceDetails(["getprop"]).wait();
        }
        catch (err) {
            this.$logger.trace(`Error while calling getprop: ${err.message}`);
        }
        if (!details || !details.name) {
            details = this.getDeviceDetails(["cat", "/system/build.prop"]).wait();
        }
        this.$logger.trace(details);
        let adbStatusInfo = AndroidDevice.ADB_DEVICE_STATUS_INFO[status];
        this.deviceInfo = {
            identifier: this.identifier,
            displayName: details.name,
            model: details.model,
            version: details.release,
            vendor: details.brand,
            platform: this.$devicePlatformsConstants.Android,
            status: adbStatusInfo ? adbStatusInfo.deviceStatus : status,
            errorHelp: adbStatusInfo ? adbStatusInfo.errorHelp : "Unknown status",
            isTablet: this.getIsTablet(details),
            type: this.getType().wait()
        };
        this.$logger.trace(this.deviceInfo);
    }
    get isEmulator() {
        return this.deviceInfo.type === "Emulator";
    }
    getApplicationInfo(applicationIdentifier) {
        return (() => {
            let files = this.fileSystem.listFiles(constants.LiveSyncConstants.ANDROID_FILES_PATH, applicationIdentifier).wait(), androidFilesMatch = files.match(/(\S+)\.abproject/), result = null;
            if (androidFilesMatch && androidFilesMatch[1]) {
                result = {
                    deviceIdentifier: this.deviceInfo.identifier,
                    configuration: androidFilesMatch[1],
                    applicationIdentifier
                };
            }
            return result;
        }).future()();
    }
    openDeviceLogStream() {
        if (this.deviceInfo.status === constants.CONNECTED_STATUS) {
            this.$logcatHelper.start(this.identifier);
        }
    }
    getDeviceDetails(shellCommandArgs) {
        return (() => {
            let details = this.adb.executeShellCommand(shellCommandArgs).wait();
            let parsedDetails = {};
            details.split(/\r?\n|\r/).forEach((value) => {
                let match = /(?:\[?ro\.build\.version|ro\.product|ro\.build)\.(.+?)]?(?:\:|=)(?:\s*?\[)?(.*?)]?$/.exec(value);
                if (match) {
                    parsedDetails[match[1]] = match[2];
                }
            });
            this.$logger.trace(parsedDetails);
            return parsedDetails;
        }).future()();
    }
    getIsTablet(details) {
        return details && (_.startsWith(details.release, "3.") || _.includes((details.characteristics || '').toLowerCase(), "tablet"));
    }
    getType() {
        return (() => {
            let runningEmulators = this.$androidEmulatorServices.getAllRunningEmulators().wait();
            if (_.includes(runningEmulators, this.identifier)) {
                return "Emulator";
            }
            return "Device";
        }).future()();
    }
}
AndroidDevice.ADB_DEVICE_STATUS_INFO = {
    "device": {
        errorHelp: null,
        deviceStatus: constants.CONNECTED_STATUS
    },
    "offline": {
        errorHelp: "The device instance is not connected to adb or is not responding.",
        deviceStatus: constants.UNREACHABLE_STATUS
    },
    "unauthorized": {
        errorHelp: "Allow USB Debugging on your device.",
        deviceStatus: constants.UNREACHABLE_STATUS
    },
    "recovery": {
        errorHelp: "Your device is in recovery mode. This mode is used to recover your phone when it is broken or to install custom roms.",
        deviceStatus: constants.UNREACHABLE_STATUS
    },
    "no permissions": {
        errorHelp: "Insufficient permissions to communicate with the device.",
        deviceStatus: constants.UNREACHABLE_STATUS
    },
};
exports.AndroidDevice = AndroidDevice;
